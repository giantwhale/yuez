# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Running Exponential Moving Average (EMA)
#'
#' Missing Values are forward filled. 
#'
#' @param x numeric vector
#' @param decay double, the decay factor
#' @param min_size if number of non-NA elements is fewer than min_size, return NA. For EMA,
#'    this parameter is only used to remove the first a few elements.
#'
#' @export
exp_moving_avg <- function(x, decay, min_size = 1L) {
    .Call('_yuez_exp_moving_avg', PACKAGE = 'yuez', x, decay, min_size)
}

#' Forward Fill NAs 
#'
#' @param x numeric vector
#' @param w integer, windows size, results are right aligned if w < 0, left aligned if w > 0
#'
#' @export
ffill <- function(x, w = 0L) {
    .Call('_yuez_ffill', PACKAGE = 'yuez', x, w)
}

#' index of the first TRUE value
#' @export
first_true <- function(x) {
    .Call('_yuez_first_true', PACKAGE = 'yuez', x)
}

#' Index of the last TRUE value
#' @export
last_true <- function(x) {
    .Call('_yuez_last_true', PACKAGE = 'yuez', x)
}

#' Running Min
#'
#' This O(N) time solution is borrowed from Stackoverflow, I think it is 
#' easier to implement than the two array solution
#'
#' at every step:
#' 
#'   if (!Deque.Empty) and (Deque.Head.Index <= CurrentIndex - T) then 
#'      Deque.ExtractHead;
#'   //Head is too old, it is leaving the window
#' 
#'   while (!Deque.Empty) and (Deque.Tail.Value > CurrentValue) do
#'      Deque.ExtractTail;
#'   //remove elements that have no chance to become minimum in the window
#' 
#'   Deque.AddTail(CurrentValue, CurrentIndex); 
#'   CurrentMin = Deque.Head.Value
#'   //Head value is minimum in the current window
#'  
#'
#' @param x numeric vector
#' @param w integer, windows size, results are right aligned if w < 0, left aligned if w > 0
#'
#' @export
running_min <- function(x, w, min_size = 1L) {
    .Call('_yuez_running_min', PACKAGE = 'yuez', x, w, min_size)
}

running_max <- function(x, w, min_size = 1L) {
    .Call('_yuez_running_max', PACKAGE = 'yuez', x, w, min_size)
}

#' Running mean
#'                                                                           ../////
#' @param x numeric vector
#' @param w integer, windows size, results are right aligned if w < 0, left aligned if w > 0
#' @param min_size if number of non-NA elements is fewer than min_size, return NA
#'
#' @export
running_mean <- function(x, w, min_size = 1L) {
    .Call('_yuez_running_mean', PACKAGE = 'yuez', x, w, min_size)
}

#' Running Standard Deviation
#'
#' @param x numeric vector
#' @param w integer, windows size, results are right aligned if w < 0, left aligned if w > 0
#' @param min_size if number of non-NA elements is fewer than min_size, return NA
#'
#' @export
running_sd <- function(x, w, min_size = 2L) {
    .Call('_yuez_running_sd', PACKAGE = 'yuez', x, w, min_size)
}

#' Running Standard Deviation assuming Mean = 0
#'
#' @param x numeric vector
#' @param w integer, windows size, results are right aligned if w < 0, left aligned if w > 0
#' @param min_size if number of non-NA elements is fewer than min_size, return NA
#'
#' @export
running_sd0 <- function(x, w, min_size = 2L) {
    .Call('_yuez_running_sd0', PACKAGE = 'yuez', x, w, min_size)
}

#' Running sum
#'
#' @param x numeric vector
#' @param w integer, windows size, results are right aligned if w < 0, left aligned if w > 0
#' @param min_size if number of non-NA elements is fewer than min_size, return NA
#'
#' @export
running_sum <- function(x, w, min_size = 1L) {
    .Call('_yuez_running_sum', PACKAGE = 'yuez', x, w, min_size)
}

